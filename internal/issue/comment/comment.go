package comment

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"prcommenter/internal/common"

	"github.com/google/go-github/github"
)

type Commenter struct {
	client    GitHubClient
	messageID string
}

type GitHubClient interface {
	CreateComment(ctx context.Context, owner string, repo string, number int, comment *github.IssueComment) (*github.IssueComment, *github.Response, error)
	ListComments(ctx context.Context, owner string, repo string, number int, opts *github.IssueListCommentsOptions) ([]*github.IssueComment, *github.Response, error)
	EditComment(ctx context.Context, owner, repo string, commentID int64, comment *github.IssueComment) (*github.IssueComment, *github.Response, error)
}

func NewCommenter(client GitHubClient) (*Commenter, error) {
	// Create a unique "id" embedded in the comment that identifies the comment generated by this pipeline+step
	// The generated "id" is unique to the specific pipeline+step, with the plugin message-id param allowing further uniqueness
	stepKey, found := os.LookupEnv("BUILDKITE_STEP_KEY")
	if !found {
		stepKey, found = os.LookupEnv("BUILDKITE_LABEL")
		if !found {
			return nil, errors.New("at least one of BUILDKITE_STEP_KEY or BUILDKITE_LABEL must be set")
		}
	}

	messageID := fmt.Sprintf("%s:%s:pr-commenter-buildkite-plugin", os.Getenv("BUILDKITE_PIPELINE_SLUG"), stepKey)
	uniqueID, found := os.LookupEnv(common.PluginPrefix + "MESSAGE_ID")
	if found {
		messageID = fmt.Sprintf("%s:%s", messageID, uniqueID)
	}

	return &Commenter{
		client:    client,
		messageID: messageID,
	}, nil
}

func (c *Commenter) formatBody(message string) string {
	return fmt.Sprintf("%s\n\n<!-- %s -->", message, c.messageID)
}

func (c *Commenter) Post(ctx context.Context, owner string, repo string, number string, message string) error {
	numberConverted, err := strconv.Atoi(number)
	if err != nil {
		return err
	}

	if message == "" {
		return errors.New("no message provided for comment")
	}
	body := c.formatBody(message)

	comment := &github.IssueComment{
		Body: &body,
	}

	_, _, err = c.client.CreateComment(ctx, owner, repo, numberConverted, comment)
	return err
}

func (c *Commenter) UpdateComment(ctx context.Context, owner string, repo string, message string, commentId int64) error {
	if message == "" {
		return errors.New("no message provided for comment")
	}
	body := c.formatBody(message)
	comment := &github.IssueComment{
		Body: &body,
	}

	_, _, err := c.client.EditComment(ctx, owner, repo, commentId, comment)
	return err
}

func (c *Commenter) FindExistingComment(ctx context.Context, owner string, repo string, number string) (*github.IssueComment, error) {
	numberConverted, err := strconv.Atoi(number)
	if err != nil {
		return nil, err
	}

	opt := &github.IssueListCommentsOptions{
		ListOptions: github.ListOptions{PerPage: 100},
	}
	for {
		comments, resp, err := c.client.ListComments(ctx, owner, repo, numberConverted, opt)
		if err != nil {
			return nil, err
		}
		for _, comment := range comments {
			if comment.Body != nil && strings.Contains(*comment.Body, c.messageID) {
				return comment, nil
			}
		}
		if resp.NextPage == 0 {
			break
		}
		opt.Page = resp.NextPage
	}
	return nil, nil
}

func (c *Commenter) MatchBody(ctx context.Context, comment *github.IssueComment, message string) bool {
	// Match for exact body content
	if comment == nil || comment.Body == nil {
		return false
	}
	return c.formatBody(message) == *comment.Body
}
